//! Code generator for CLI Action enum and to_game_command() from OpenAPI spec.
//!
//! Usage:
//!   cargo run --bin gen > src/cli_generated.rs
//!
//! This parses openapi.yaml and generates:
//! - Action enum with Clap derive attributes
//! - impl Action with to_game_command() method

use serde_yaml::Value;
use std::collections::HashSet;
use std::fs;

fn main() {
    let spec_path = "openapi.yaml";
    let content = fs::read_to_string(spec_path).expect("Failed to read openapi.yaml");
    let spec: Value = serde_yaml::from_str(&content).expect("Failed to parse YAML");

    let schemas = &spec["components"]["schemas"];

    // Collect all *Params schemas
    let mut commands: Vec<CommandDef> = Vec::new();

    if let Value::Mapping(map) = schemas {
        for (key, value) in map {
            if let Value::String(name) = key {
                if name.ends_with("Params") {
                    let action_name = name.strip_suffix("Params").unwrap();
                    let cmd_schema_name = format!("{}Command", action_name);

                    // Check if command schema exists and has params
                    let cmd_schema = &schemas[&cmd_schema_name];

                    // Get description from *Command schema
                    let description = cmd_schema["description"].as_str().unwrap_or("").to_string();

                    // Get action const value (for the action string field)
                    let action_const = cmd_schema["properties"]["action"]["const"]
                        .as_str()
                        .map(|s| s.to_string())
                        .unwrap_or_else(|| to_camel_case(action_name));

                    // Check if the command schema has a params field
                    let has_params = cmd_schema["properties"]["params"].as_mapping().is_some()
                        || cmd_schema["properties"]["params"]["$ref"]
                            .as_str()
                            .is_some();

                    // Parse params
                    let params = parse_params(value);

                    commands.push(CommandDef {
                        name: action_name.to_string(),
                        action_const,
                        description,
                        params,
                        has_params,
                    });
                }
            }
        }
    }

    // Sort commands alphabetically for consistent output
    commands.sort_by(|a, b| a.name.cmp(&b.name));

    // Generate output
    println!("// This file is auto-generated by `cargo run --bin gen`");
    println!("// Do not edit manually. Regenerate with:");
    println!("//   cargo run --bin gen > src/cli_generated.rs");
    println!("//");
    println!("// Included via include!() in cli.rs");
    println!();
    generate_action_enum(&commands);
    println!();
    generate_to_game_command(&commands);
}

#[derive(Debug)]
struct CommandDef {
    name: String,         // e.g., "MoveUnit"
    action_const: String, // e.g., "moveUnit"
    description: String,
    params: Vec<ParamDef>,
    has_params: bool, // Whether the command schema has a params field
}

#[derive(Debug)]
struct ParamDef {
    name: String, // e.g., "unitId"
    param_type: ParamType,
    description: String,
    required: bool,
    has_default: bool, // Boolean fields with default are treated as required bool
}

#[derive(Debug, Clone)]
enum ParamType {
    Integer,
    String,
    Boolean,
    Array(Box<ParamType>),
}

fn parse_params(schema: &Value) -> Vec<ParamDef> {
    let mut params = Vec::new();

    let required: HashSet<String> = schema["required"]
        .as_sequence()
        .map(|seq| {
            seq.iter()
                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                .collect()
        })
        .unwrap_or_default();

    if let Value::Mapping(props) = &schema["properties"] {
        for (key, value) in props {
            if let Value::String(name) = key {
                let param_type = parse_type(value);
                let description = value["description"].as_str().unwrap_or("").to_string();
                let is_required = required.contains(name);
                // Boolean fields with a default value should be treated as required bool
                let has_default = value.get("default").is_some();

                params.push(ParamDef {
                    name: name.clone(),
                    param_type,
                    description,
                    required: is_required,
                    has_default,
                });
            }
        }
    }

    // Sort params: required first, then alphabetically
    params.sort_by(|a, b| match (a.required, b.required) {
        (true, false) => std::cmp::Ordering::Less,
        (false, true) => std::cmp::Ordering::Greater,
        _ => a.name.cmp(&b.name),
    });

    params
}

fn parse_type(schema: &Value) -> ParamType {
    match schema["type"].as_str() {
        Some("integer") => ParamType::Integer,
        Some("string") => ParamType::String,
        Some("boolean") => ParamType::Boolean,
        Some("array") => {
            let items = &schema["items"];
            ParamType::Array(Box::new(parse_type(items)))
        }
        _ => ParamType::String, // Default to string for unknown types
    }
}

fn generate_action_enum(commands: &[CommandDef]) {
    println!(
        "/// Game commands generated from OpenAPI spec ({} commands)",
        commands.len()
    );
    println!("/// See: https://github.com/becked/OldWorldAPIEndpoint/blob/main/docs/openapi.yaml");
    println!("#[derive(Subcommand, Debug)]");
    println!("pub enum Action {{");

    for cmd in commands {
        // Doc comment
        if !cmd.description.is_empty() {
            println!("    /// {}", cmd.description);
        }

        // Variant name in PascalCase
        let variant_name = &cmd.name;

        if cmd.params.is_empty() {
            println!("    {},", variant_name);
        } else {
            println!("    {} {{", variant_name);

            for param in &cmd.params {
                // Doc comment for param
                if !param.description.is_empty() {
                    println!("        /// {}", param.description);
                }

                // Field with Clap attribute
                let rust_field = to_snake_case(&param.name);
                let rust_type = param_to_rust_type(param);

                println!("        #[arg(long)]");
                println!("        {}: {},", rust_field, rust_type);
            }

            println!("    }},");
        }
    }

    println!("}}");
}

fn generate_to_game_command(commands: &[CommandDef]) {
    println!("impl Action {{");
    println!("    /// Convert CLI action to generated GameCommand type");
    println!("    pub fn to_game_command(&self) -> crate::client::types::GameCommand {{");
    println!("        use crate::client::types::{{GameCommand, *}};");
    println!();
    println!("        match self {{");

    for cmd in commands {
        let variant_name = &cmd.name;
        let cmd_struct_name = format!("{}Command", variant_name);
        let params_struct_name = format!("{}Params", variant_name);

        if cmd.params.is_empty() {
            // Command with no params
            if cmd.has_params {
                // Command struct has params field but params struct is empty
                println!(
                    "            Action::{} => GameCommand::{}({} {{",
                    variant_name, cmd_struct_name, cmd_struct_name
                );
                println!(
                    "                action: \"{}\".to_string(),",
                    cmd.action_const
                );
                println!("                params: {} {{}},", params_struct_name);
                println!("                request_id: None,");
                println!("            }}),");
            } else {
                // Command struct has no params field at all
                println!(
                    "            Action::{} => GameCommand::{}({} {{",
                    variant_name, cmd_struct_name, cmd_struct_name
                );
                println!(
                    "                action: \"{}\".to_string(),",
                    cmd.action_const
                );
                println!("                request_id: None,");
                println!("            }}),");
            }
        } else {
            // Command with params
            // Collect field names
            let fields: Vec<String> = cmd.params.iter().map(|p| to_snake_case(&p.name)).collect();

            // Start match arm
            println!(
                "            Action::{} {{ {} }} => {{",
                variant_name,
                fields.join(", ")
            );

            // Create params struct
            println!("                let params = {} {{", params_struct_name);

            for param in &cmd.params {
                let rust_field = to_snake_case(&param.name);
                let value = match (&param.param_type, param.required, param.has_default) {
                    // Boolean with default: it's a required bool field in the generated struct
                    (ParamType::Boolean, _, true) => format!("*{}", rust_field),
                    // Optional boolean without default: Option<bool>
                    (ParamType::Boolean, false, false) => {
                        format!("if *{} {{ Some(true) }} else {{ None }}", rust_field)
                    }
                    // Required boolean without default (shouldn't happen but handle it)
                    (ParamType::Boolean, true, false) => format!("*{}", rust_field),
                    // Required integers/strings
                    (ParamType::Integer, true, _) => format!("*{}", rust_field),
                    (ParamType::String, true, _) => format!("{}.clone()", rust_field),
                    // Optional integers - need to dereference
                    (ParamType::Integer, false, _) => format!("*{}", rust_field),
                    (ParamType::String, false, _) => format!("{}.clone()", rust_field),
                    // Arrays
                    (ParamType::Array(_), _, _) => format!("{}.clone()", rust_field),
                };
                println!("                    {}: {},", rust_field, value);
            }

            println!("                }};");
            // Silence unused variable warning if command doesn't have params field
            if !cmd.has_params {
                println!("                let _ = params;");
            }

            if cmd.has_params {
                println!(
                    "                GameCommand::{}({} {{",
                    cmd_struct_name, cmd_struct_name
                );
                println!(
                    "                    action: \"{}\".to_string(),",
                    cmd.action_const
                );
                println!("                    params,");
                println!("                    request_id: None,");
                println!("                }})");
            } else {
                // Shouldn't happen (has params but command doesn't use them) but handle it
                println!(
                    "                GameCommand::{}({} {{",
                    cmd_struct_name, cmd_struct_name
                );
                println!(
                    "                    action: \"{}\".to_string(),",
                    cmd.action_const
                );
                println!("                    request_id: None,");
                println!("                }})");
            }
            println!("            }}");
        }
    }

    println!("        }}");
    println!("    }}");
    println!("}}");
}

fn param_to_rust_type(param: &ParamDef) -> String {
    let base_type = match &param.param_type {
        ParamType::Integer => "i64",
        ParamType::String => "String",
        ParamType::Boolean => "bool",
        ParamType::Array(inner) => {
            let inner_type = match inner.as_ref() {
                ParamType::Integer => "i64",
                ParamType::String => "String",
                ParamType::Boolean => "bool",
                ParamType::Array(_) => "serde_json::Value", // Nested arrays become generic
            };
            return if param.required {
                format!("Vec<{}>", inner_type)
            } else {
                format!("Option<Vec<{}>>", inner_type)
            };
        }
    };

    if param.required {
        base_type.to_string()
    } else {
        match param.param_type {
            // Booleans with default are effectively required (have a default value)
            // Booleans without default are still just bool flags in CLI
            ParamType::Boolean => "bool".to_string(),
            _ => format!("Option<{}>", base_type),
        }
    }
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }
    result
}

fn to_camel_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = false;
    for (i, c) in s.chars().enumerate() {
        if i == 0 {
            result.push(c.to_lowercase().next().unwrap());
        } else if c == '_' || c == '-' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_uppercase().next().unwrap());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }
    result
}
