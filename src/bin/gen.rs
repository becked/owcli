//! Code generator for CLI Action enum and to_game_command() from OpenAPI spec.
//!
//! Usage:
//!   cargo run --bin gen > src/cli_generated.rs
//!
//! This parses openapi.yaml and generates:
//! - Action enum with Clap derive attributes
//! - impl Action with to_game_command() method

use serde_yaml::Value;
use std::collections::HashSet;
use std::fs;

fn main() {
    let spec_path = "openapi.yaml";
    let content = fs::read_to_string(spec_path).expect("Failed to read openapi.yaml");
    let spec: Value = serde_yaml::from_str(&content).expect("Failed to parse YAML");

    let schemas = &spec["components"]["schemas"];

    // Get valid action names from GameCommand action enum
    let valid_actions: HashSet<String> = schemas["GameCommand"]["properties"]["action"]["enum"]
        .as_sequence()
        .map(|seq| {
            seq.iter()
                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                .collect()
        })
        .unwrap_or_default();

    // Collect all *Params schemas that have corresponding actions
    let mut commands: Vec<CommandDef> = Vec::new();

    if let Value::Mapping(map) = schemas {
        for (key, value) in map {
            if let Value::String(name) = key {
                if name.ends_with("Params") {
                    let action_name = name.strip_suffix("Params").unwrap();

                    // Convert PascalCase to camelCase for action string
                    let action_const = to_camel_case(action_name);

                    // Skip if this action doesn't exist in the enum
                    if !valid_actions.contains(&action_const) {
                        eprintln!("Warning: Skipping {} - no matching action in enum", name);
                        continue;
                    }

                    // Get description from params schema
                    let description = value["description"].as_str().unwrap_or("").to_string();

                    // Parse params
                    let params = parse_params(value);

                    commands.push(CommandDef {
                        name: action_name.to_string(),
                        action_const,
                        description,
                        params,
                    });
                }
            }
        }
    }

    // Sort commands alphabetically for consistent output
    commands.sort_by(|a, b| a.name.cmp(&b.name));

    // Generate output
    println!("// This file is auto-generated by `cargo run --bin gen`");
    println!("// Do not edit manually. Regenerate with:");
    println!("//   cargo run --bin gen > src/cli_generated.rs");
    println!("//");
    println!("// Included via include!() in cli.rs");
    println!();
    generate_action_enum(&commands);
    println!();
    generate_to_game_command(&commands);
}

#[derive(Debug)]
struct CommandDef {
    name: String,         // e.g., "MoveUnit"
    action_const: String, // e.g., "moveUnit"
    description: String,
    params: Vec<ParamDef>,
}

#[derive(Debug)]
struct ParamDef {
    name: String, // e.g., "unitId"
    param_type: ParamType,
    description: String,
    required: bool,
    has_default: bool, // Boolean fields with default are treated as required bool
}

#[derive(Debug, Clone)]
enum ParamType {
    Integer,
    String,
    Boolean,
    Array(Box<ParamType>),
}

fn parse_params(schema: &Value) -> Vec<ParamDef> {
    let mut params = Vec::new();

    let required: HashSet<String> = schema["required"]
        .as_sequence()
        .map(|seq| {
            seq.iter()
                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                .collect()
        })
        .unwrap_or_default();

    if let Value::Mapping(props) = &schema["properties"] {
        for (key, value) in props {
            if let Value::String(name) = key {
                let param_type = parse_type(value);
                let description = value["description"].as_str().unwrap_or("").to_string();
                let is_required = required.contains(name);
                // Boolean fields with a default value should be treated as required bool
                let has_default = value.get("default").is_some();

                params.push(ParamDef {
                    name: name.clone(),
                    param_type,
                    description,
                    required: is_required,
                    has_default,
                });
            }
        }
    }

    // Sort params: required first, then alphabetically
    params.sort_by(|a, b| match (a.required, b.required) {
        (true, false) => std::cmp::Ordering::Less,
        (false, true) => std::cmp::Ordering::Greater,
        _ => a.name.cmp(&b.name),
    });

    params
}

fn parse_type(schema: &Value) -> ParamType {
    match schema["type"].as_str() {
        Some("integer") => ParamType::Integer,
        Some("string") => ParamType::String,
        Some("boolean") => ParamType::Boolean,
        Some("array") => {
            let items = &schema["items"];
            ParamType::Array(Box::new(parse_type(items)))
        }
        _ => ParamType::String, // Default to string for unknown types
    }
}

fn generate_action_enum(commands: &[CommandDef]) {
    println!(
        "/// Game commands generated from OpenAPI spec ({} commands)",
        commands.len()
    );
    println!("/// See: https://github.com/becked/OldWorldAPIEndpoint/blob/main/docs/openapi.yaml");
    println!("#[derive(Subcommand, Debug)]");
    println!("pub enum Action {{");

    for cmd in commands {
        // Doc comment
        if !cmd.description.is_empty() {
            println!("    /// {}", cmd.description);
        }

        // Variant name in PascalCase
        let variant_name = &cmd.name;

        if cmd.params.is_empty() {
            println!("    {},", variant_name);
        } else {
            println!("    {} {{", variant_name);

            for param in &cmd.params {
                // Doc comment for param
                if !param.description.is_empty() {
                    println!("        /// {}", param.description);
                }

                // Field with Clap attribute
                let rust_field = escape_keyword(&to_snake_case(&param.name));
                let rust_type = param_to_rust_type(param);

                println!("        #[arg(long)]");
                println!("        {}: {},", rust_field, rust_type);
            }

            println!("    }},");
        }
    }

    println!("}}");
}

fn generate_to_game_command(commands: &[CommandDef]) {
    println!("impl Action {{");
    println!("    /// Convert CLI action to generated GameCommand type");
    println!("    pub fn to_game_command(&self) -> crate::client::types::GameCommand {{");
    println!("        use crate::client::types::{{GameCommand, GameCommandAction}};");
    println!();
    println!("        match self {{");

    for cmd in commands {
        let variant_name = &cmd.name;
        // Convert camelCase action to PascalCase for enum variant
        let enum_variant = to_pascal_case(&cmd.action_const);

        if cmd.params.is_empty() {
            // Command with no params
            println!(
                "            Action::{} => GameCommand {{",
                variant_name
            );
            println!(
                "                action: GameCommandAction::{},",
                enum_variant
            );
            println!("                params: serde_json::Map::new(),");
            println!("                request_id: None,");
            println!("            }},");
        } else {
            // Command with params
            // Collect field names (escaped for Rust keywords)
            let fields: Vec<String> = cmd.params.iter().map(|p| escape_keyword(&to_snake_case(&p.name))).collect();

            // Start match arm
            println!(
                "            Action::{} {{ {} }} => {{",
                variant_name,
                fields.join(", ")
            );

            // Build params map
            println!("                let mut params = serde_json::Map::new();");

            for param in &cmd.params {
                let rust_field = escape_keyword(&to_snake_case(&param.name));
                let json_key = &param.name; // Keep original name for JSON

                match (&param.param_type, param.required) {
                    // Required fields - always insert
                    (ParamType::Integer, true) => {
                        println!(
                            "                params.insert(\"{}\".to_string(), serde_json::Value::Number((*{}).into()));",
                            json_key, rust_field
                        );
                    }
                    (ParamType::String, true) => {
                        println!(
                            "                params.insert(\"{}\".to_string(), serde_json::Value::String({}.clone()));",
                            json_key, rust_field
                        );
                    }
                    (ParamType::Boolean, true) => {
                        println!(
                            "                params.insert(\"{}\".to_string(), serde_json::Value::Bool(*{}));",
                            json_key, rust_field
                        );
                    }
                    // Optional fields - only insert if Some/true
                    (ParamType::Integer, false) => {
                        println!(
                            "                if let Some(v) = {} {{ params.insert(\"{}\".to_string(), serde_json::Value::Number((*v).into())); }}",
                            rust_field, json_key
                        );
                    }
                    (ParamType::String, false) => {
                        println!(
                            "                if let Some(v) = {} {{ params.insert(\"{}\".to_string(), serde_json::Value::String(v.clone())); }}",
                            rust_field, json_key
                        );
                    }
                    (ParamType::Boolean, false) => {
                        // For CLI bool flags, only insert if true
                        println!(
                            "                if *{} {{ params.insert(\"{}\".to_string(), serde_json::Value::Bool(true)); }}",
                            rust_field, json_key
                        );
                    }
                    // Arrays
                    (ParamType::Array(_), true) => {
                        println!(
                            "                params.insert(\"{}\".to_string(), serde_json::to_value({}).unwrap());",
                            json_key, rust_field
                        );
                    }
                    (ParamType::Array(_), false) => {
                        println!(
                            "                if let Some(v) = {} {{ params.insert(\"{}\".to_string(), serde_json::to_value(v).unwrap()); }}",
                            rust_field, json_key
                        );
                    }
                }
            }

            println!("                GameCommand {{");
            println!(
                "                    action: GameCommandAction::{},",
                enum_variant
            );
            println!("                    params,");
            println!("                    request_id: None,");
            println!("                }}");
            println!("            }}");
        }
    }

    println!("        }}");
    println!("    }}");
    println!("}}");
}

fn param_to_rust_type(param: &ParamDef) -> String {
    let base_type = match &param.param_type {
        ParamType::Integer => "i64",
        ParamType::String => "String",
        ParamType::Boolean => "bool",
        ParamType::Array(inner) => {
            let inner_type = match inner.as_ref() {
                ParamType::Integer => "i64",
                ParamType::String => "String",
                ParamType::Boolean => "bool",
                ParamType::Array(_) => "serde_json::Value", // Nested arrays become generic
            };
            return if param.required {
                format!("Vec<{}>", inner_type)
            } else {
                format!("Option<Vec<{}>>", inner_type)
            };
        }
    };

    if param.required {
        base_type.to_string()
    } else {
        match param.param_type {
            // Booleans with default are effectively required (have a default value)
            // Booleans without default are still just bool flags in CLI
            ParamType::Boolean => "bool".to_string(),
            _ => format!("Option<{}>", base_type),
        }
    }
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }
    result
}

fn to_camel_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = false;
    for (i, c) in s.chars().enumerate() {
        if i == 0 {
            result.push(c.to_lowercase().next().unwrap());
        } else if c == '_' || c == '-' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_uppercase().next().unwrap());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }
    result
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;
    for c in s.chars() {
        if c == '_' || c == '-' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_uppercase().next().unwrap());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }
    result
}

/// Escape Rust reserved keywords by prefixing with r#
fn escape_keyword(name: &str) -> String {
    const KEYWORDS: &[&str] = &[
        "as", "break", "const", "continue", "crate", "else", "enum", "extern",
        "false", "fn", "for", "if", "impl", "in", "let", "loop", "match", "mod",
        "move", "mut", "pub", "ref", "return", "self", "Self", "static", "struct",
        "super", "trait", "true", "type", "unsafe", "use", "where", "while",
        "async", "await", "dyn", "abstract", "become", "box", "do", "final",
        "macro", "override", "priv", "typeof", "unsized", "virtual", "yield", "try",
    ];
    if KEYWORDS.contains(&name) {
        format!("r#{}", name)
    } else {
        name.to_string()
    }
}
